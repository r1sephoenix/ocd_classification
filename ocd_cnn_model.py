# -*- coding: utf-8 -*-
"""OCD-CNN Model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1J2mzhjRm2guAj6qk5W43QSUqnWarIYwa
"""

pip install mne

# Connecting drive

from google.colab import drive
drive.mount('/content/drive')

# Importing
import mne
import pandas as pd
import os
import matplotlib.pyplot as plt
from mne.preprocessing import ICA

directory = '/content/drive/MyDrive/sample_data'

"""**Reading and Filtering**"""

import numpy as np
control= []
ocd = []
for filename in os.listdir(directory + '/CONTROL'):
    if filename.endswith('.vhdr'):
      filepath = os.path.join(directory +'/CONTROL', filename)
      raw = mne.io.read_raw_brainvision(filepath, preload=True)
      raw.set_montage('standard_1020')
      raw.filter(0.1, 40)
      raw.notch_filter(freqs=[50], verbose=True)
      control.append(raw)
for filename in os.listdir(directory + '/OCD'):
    if filename.endswith('.vhdr'):
      filepath = os.path.join(directory +'/OCD', filename)
      raw = mne.io.read_raw_brainvision(filepath, preload=True)
      raw.set_montage('standard_1020')
      raw.filter(0.1, 40)
      raw.notch_filter(freqs=[50], verbose=True)
      ocd.append(raw)

for raw in ocd:
  print(raw.info)
  raw.plot_psd(average = True)
for raw in control:
  print(raw.info)
  raw.plot_psd(average = True)

"""**Independent Component Analysis**"""

for raw in ocd:
      ica_ocd = mne.preprocessing.ICA(n_components=20)
      ica_ocd.fit(raw)
      ica_ocd.plot_components()  # Inspect components
      ica_ocd.apply(raw)
      a = int(input("Enter the 1st ica's you want the properties of "))
      b = int(input("Enter the 2nd ica's you want the properties of "))
      c = int(input("Enter the 3rd ica's you want the properties of "))
      ica_ocd.plot_properties(raw, picks = [a,b,c])
      # write code to take input from useer of which component tod drop
      x = int(input("Give the 1st ica components with artifacts "))
      y = int(input("Give the 2nd ica components with artifacts "))
      z = int(input("Give the 3rd ica components with artifacts "))
      ica_ocd.exclude = [x,y,z]
      ica_ocd.apply(raw)

for raw in control:
      ica_control = mne.preprocessing.ICA(n_components=20)
      ica_control.fit(raw)
      ica_control.plot_components()  # Inspect components
      ica_control.apply(raw)
      a = int(input("Enter the 1st ica's you want the properties of "))
      b = int(input("Enter the 2nd ica's you want the properties of "))
      c = int(input("Enter the 3rd ica's you want the properties of "))
      ica_control.plot_properties(raw, picks = [a,b,c])
      # write code to take input from useer of which component tod drop
      x = int(input("Give the 1st ica components with artifacts "))
      y = int(input("Give the 2nd ica components with artifacts "))
      z = int(input("Give the 3rd ica components with artifacts "))
      ica_control.exclude = [x,y,z]
      ica_control.apply(raw)

# Check for these three types of artifacts
#1. eye blinks
#2. heart related components
#3. Bad channels

"""**Segmenting Data into Epochs**"""

for raw in ocd:
  print(raw.annotations)
  print(raw.annotations.description)
  events, event_id = mne.events_from_annotations(raw)
  print("Event ids")
  print(event_id)

# Cutting Epochs

# S11 S21 S31 - Beginning of the fixation period
# S12 S22 S32 (200ms) - Overlap Period
# S10 S20 S30 (800ms) - Antisaccade Priod
# S14 S24 S34 (1min) - Feedback Question Period
# S15 S25 S35 (1000ms) - Black Screen Period

# take this epochs separately take for antisaccade and overlap period only and make a df
antisaccade_all_ocd = []
fixation_all_ocd = []
antisaccade_all_control = []
fixation_all_control = []
p_id = []
i = 0
for raw in ocd:
    events, event_id = mne.events_from_annotations(raw)
    antisaccade_event_ids = {'Stimulus/S 10':10, 'Stimulus/S 20':20, 'Stimulus/S 30':30}  # S10, S20, S30
    fixation_event_ids = {'Stimulus/S 11':11, 'Stimulus/S 21':21, 'Stimulus/S 31':31}  # S12, S22, S32

    antisaccade_epochs_ocd = mne.Epochs(raw, events, event_id = antisaccade_event_ids, tmin=-0.2, tmax=0.8, preload=True)
    fixation_epochs_ocd = mne.Epochs(raw, events, event_id = fixation_event_ids, tmin=-0.2, tmax=0.2, preload=True)

    antisaccade_data_ocd = antisaccade_epochs_ocd.get_data()
    fixation_data_ocd = fixation_epochs_ocd.get_data()

    antisaccade_all_ocd.append(antisaccade_data_ocd)
    fixation_all_ocd.append(fixation_data_ocd)
    p_id.append(i)
    i+=1
    print("Antisaccade Data Shape:", antisaccade_data_ocd.shape)
    print("Fixation Data Shape:", fixation_data_ocd.shape)


for raw in control:
    events, event_id = mne.events_from_annotations(raw)
    antisaccade_event_ids = {'Stimulus/S 10':10, 'Stimulus/S 20':20, 'Stimulus/S 30':30}  # S10, S20, S30
    fixation_event_ids = {'Stimulus/S 11':11, 'Stimulus/S 21':21, 'Stimulus/S 31':31}  # S12, S22, S32

    antisaccade_epochs_control = mne.Epochs(raw, events, event_id = antisaccade_event_ids, tmin=-0.2, tmax=0.8, preload=True)
    fixation_epochs_control = mne.Epochs(raw, events, event_id = fixation_event_ids, tmin=-0.2, tmax=0.2, preload=True)

    antisaccade_data_control = antisaccade_epochs_control.get_data() # epochs, channels, timepoints
    fixation_data_control = fixation_epochs_control.get_data()

    antisaccade_all_control.append(antisaccade_data_control)
    fixation_all_control.append(fixation_data_control) # samples, epochs, channels, timepoints

    print("Antisaccade Data Shape:", antisaccade_data_control.shape)
    print("Fixation Data Shape:", fixation_data_control.shape)

for data in antisaccade_all_ocd:
    print("Shape of Antisaccade OCD",data.shape)

for data in fixation_all_ocd:
    print("Shape of Fixation OCD" ,data.shape)

for data in antisaccade_all_control:
    print("Shape of Antisaccade Control", data.shape)

for data in fixation_all_control:
    print("Shape of Fixation Control", data.shape)

# Padding of antisaccade_all_ocd, antisaccade_all_control, fixation_all_ocd, fixation_all_control
# Determine maximum shapes
max_antisaccade_epochs = max([data.shape[0] for data in antisaccade_all_ocd])
max_fixation_epochs = max([data.shape[0] for data in fixation_all_ocd])

max_antisaccade_epochs = max(data.shape[0] for data in antisaccade_data_control)
max_fixation_epochs = max(data.shape[0] for data in fixation_data_control)

max_epochs = max([max_antisaccade_epochs, max_fixation_epochs, max_antisaccade_epochs, max_fixation_epochs])

for i in range(len(antisaccade_all_ocd)):
    if antisaccade_all_ocd[i].shape[0] < max_epochs:
        pad_epochs = max_epochs - antisaccade_all_ocd[i].shape[0]
        antisaccade_all_ocd[i] = np.pad(antisaccade_all_ocd[i],
                                        ((0, pad_epochs), (0, 0), (0, 0)),
                                        'constant', constant_values=0)

for i in range(len(fixation_all_ocd)):
    if fixation_all_ocd[i].shape[0] < max_epochs:
        pad_epochs = max_epochs - fixation_all_ocd[i].shape[0]
        fixation_all_ocd[i] = np.pad(fixation_all_ocd[i],
                                     ((0, pad_epochs), (0, 0), (0, 0)),
                                     'constant', constant_values=0)


for i in range(len(antisaccade_all_control)):
    if antisaccade_all_control[i].shape[0] < max_epochs:
        pad_epochs = max_epochs - antisaccade_all_control[i].shape[0]
        antisaccade_all_control[i] = np.pad(antisaccade_all_control[i],
                                        ((0, pad_epochs), (0, 0), (0, 0)),
                                        'constant', constant_values=0)

for i in range(len(fixation_all_control)):
    if fixation_all_control[i].shape[0] < max_epochs:
        pad_epochs = max_epochs - fixation_all_control[i].shape[0]
        fixation_all_ocd[i] = np.pad(fixation_all_control[i],
                                     ((0, pad_epochs), (0, 0), (0, 0)),
                                     'constant', constant_values=0)

antisaccade_epochs.compute_psd().plot(picks = 'eeg')

band = [(4,8 ,'theta'),(8,12,'alpha') , (12,30,'beta' )]
antisaccade_epochs.plot_psd_topomap(bands=band, vlim='joint')

antisaccade_evoked = antisaccade_epochs.average()
antisaccade_evoked.plot()
antisaccade_evoked.plot_image()

pip install PyWavelets

# do the feature extraction - wavelet transform

import pywt
import numpy as np

def apply_wavelet_transform(data, wavelet='cmor', scales = [2,4, 8, 12, 30]):
    """
    Apply Continuous Wavelet Transform (CWT) on EEG data.
    :param data: EEG data of shape (epochs, channels, timepoints)
    :return: Wavelet transformed data of shape (epochs, channels, scales, timepoints)
    """
    transformed_data = []
    for epoch in data:
        transformed_epoch = []
        for channel in epoch:
            coeffs, _ = pywt.cwt(channel, scales, wavelet)  # CWT on single channel
            transformed_epoch.append(coeffs)
        transformed_data.append(np.array(transformed_epoch))
    return transformed_data

antisaccade_wavelet_all_control = []
fixation_wavelet_all_control = []
antisaccade_wavelet_all_ocd = []
fixation_wavelet_all_ocd = []

for data in antisaccade_all_control:
    wavelet_data = apply_wavelet_transform(data) #(epochs, channels, scales, timepoints)
    antisaccade_wavelet_all_control.append(wavelet_data)

for data in fixation_all_control:
    wavelet_data = apply_wavelet_transform(data)
    fixation_wavelet_all_control.append(wavelet_data)


for data in antisaccade_all_ocd:
    wavelet_data = apply_wavelet_transform(data)
    antisaccade_wavelet_all_ocd.append(wavelet_data)


# number of samples = no of people(p_id) - check
# size of all anti/fix data same - padding

for data in fixation_all_ocd:
    wavelet_data = apply_wavelet_transform(data)
    fixation_wavelet_all_ocd.append(wavelet_data)

fixation_wavelet_all_ocd = np.array(fixation_wavelet_all_ocd)
print(fixation_wavelet_all_ocd.shape)
antisaccade_wavelet_all_ocd = np.array(antisaccade_wavelet_all_ocd)
print(antisaccade_wavelet_all_ocd.shape)

# OCD Data: Concatenate along time axis (axis=4)
ocd_X = np.concatenate((fixation_wavelet_all_ocd, antisaccade_wavelet_all_ocd), axis=4)  # Shape: (2, 301, 65, 5, 702)

# Control Data: Concatenate along time axis (axis=4)
control_X = np.concatenate((fixation_wavelet_all_control, antisaccade_wavelet_all_control), axis=4)  # Shape: (2, 301, 65, 5, 702)

print(ocd_X.shape)      # Expected: (2, 301, 65, 5, 702)
print(control_X.shape)  # Expected: (2, 301, 65, 5, 702)

"""**Combining Data and Making a Dataset**"""

X = np.stack((ocd_X, control_X), axis=0)

num_ocd = ocd_X.shape[0]
num_control = control_X.shape[0]
y = np.concatenate((np.zeros((num_ocd, 1)), np.ones((num_control, 1))), axis=0)

"""**Applying CNN Model to the dataset**"""

import numpy as np
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout
from tensorflow.keras.utils import to_categorical
from sklearn.model_selection import train_test_split

print(X.shape, y.shape) # (4, 301, 65, 5, 702), (4,1)

# Define a 3D CNN model
model = Sequential([
    Conv3D(32, (3, 3, 3), activation='relu', input_shape=(301, 65, 5, 702)),
    MaxPooling3D((2, 2, 2)),

    Conv3D(64, (3, 3, 3), activation='relu'),
    MaxPooling3D((2, 2, 2)),

    Flatten(),
    Dense(128, activation='relu'),
    Dropout(0.5),
    Dense(1, activation='sigmoid')  # Binary classification
])

# Compile model
model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# Train model
model.fit(X, y, epochs=20, batch_size=1, validation_split=0.5)  # Small dataset, batch_size = 1

# Print model summary
model.summary()

from sklearn.model_selection import train_test_split

# Splitting the dataset (80% train, 20% test)
X_train, X_test, y_train, y_test = train_test_split( X, y, test_size=0.2, stratify=y )

print("Train Shape:", X_train.shape, y_train.shape)
print("Test Shape:", X_test.shape, y_test.shape)

import matplotlib.pyplot as plt

plt.figure(figsize=(12, 4))
plt.subplot(1, 2, 1)
plt.plot(history.history['accuracy'], label='Train Accuracy')
plt.plot(history.history['val_accuracy'], label='Val Accuracy')
plt.legend()
plt.title("Model Accuracy")

plt.subplot(1, 2, 2)
plt.plot(history.history['loss'], label='Train Loss')
plt.plot(history.history['val_loss'], label='Val Loss')
plt.legend()
plt.title("Model Loss")

plt.show()

"""**_____________END_____________**"""